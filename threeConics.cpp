/*************************************************************************
 *                                                                       *
 * polyjam, a polynomial solver generator for C++                        *
 * Copyright (C) 2015 Laurent Kneip, The Australian National University  *
 *                                                                       *
 * This program is free software: you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation, either version 3 of the License, or     *
 * (at your option) any later version.                                   *
 *                                                                       *
 * This program is distributed in the hope that it will be useful,       *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 * GNU General Public License for more details.                          *
 *                                                                       *
 * You should have received a copy of the GNU General Public License     *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 *                                                                       *
 *************************************************************************/

//This code is automatically generated by polyjam for solving threeConics.
//It is licensed under the GNU GPL terms.
//Please contact the author of polyjam for proprietary use.

#include "threeConics.hpp"


void
polyjam::threeConics::initRow(
    Eigen::MatrixXd  & M2,
    const Eigen::MatrixXd & M1,
    int row2,
    int row1,
    const int * cols2,
    const int * cols1,
    size_t numberCols )
{
  for( int i = 0; i < numberCols; i++ )
    M2(row2,cols2[i]) = M1(row1,cols1[i]);
}

void
polyjam::threeConics::solve( Eigen::Matrix3d & A1, Eigen::Matrix3d & A2, Eigen::Matrix3d & A3, Eigen::Vector3d & b1, Eigen::Vector3d & b2, Eigen::Vector3d & b3, double c1, double c2, double c3, std::vector< Eigen::Matrix<double,3,1> > & solutions )
{
Eigen::MatrixXd M1(3,10);
M1.fill(0.0);
M1(0,0) = A1(0,0); M1(0,1) = A1(1,0)+A1(0,1); M1(0,2) = A1(1,1); M1(0,3) = A1(2,0)+A1(0,2); M1(0,4) = A1(2,1)+A1(1,2); M1(0,5) = A1(2,2); M1(0,6) = b1[0]; M1(0,7) = b1[1]; M1(0,8) = b1[2]; M1(0,9) = c1; 
M1(1,0) = A2(0,0); M1(1,1) = A2(1,0)+A2(0,1); M1(1,2) = A2(1,1); M1(1,3) = A2(2,0)+A2(0,2); M1(1,4) = A2(2,1)+A2(1,2); M1(1,5) = A2(2,2); M1(1,6) = b2[0]; M1(1,7) = b2[1]; M1(1,8) = b2[2]; M1(1,9) = c2; 
M1(2,0) = A3(0,0); M1(2,1) = A3(1,0)+A3(0,1); M1(2,2) = A3(1,1); M1(2,3) = A3(2,0)+A3(0,2); M1(2,4) = A3(2,1)+A3(1,2); M1(2,5) = A3(2,2); M1(2,6) = b3[0]; M1(2,7) = b3[1]; M1(2,8) = b3[2]; M1(2,9) = c3; 

//swap the columns to have the leading monomials in the front
Eigen::MatrixXd M1temp(3,10);
M1temp.col(0) = M1.col(0);
M1temp.col(1) = M1.col(1);
M1temp.col(2) = M1.col(2);
M1temp.col(3) = M1.col(3);
M1temp.col(4) = M1.col(4);
M1temp.col(5) = M1.col(5);
M1temp.col(6) = M1.col(6);
M1temp.col(7) = M1.col(7);
M1temp.col(8) = M1.col(8);
M1temp.col(9) = M1.col(9);

Eigen::Matrix<double,3,3> temp = M1temp.topLeftCorner(3,3).inverse();
Eigen::Matrix<double,3,10> temp2 = temp * M1temp;
M1temp = temp2;

//Swap the columns back to the original form
M1.col(0) = M1temp.col(0);
M1.col(1) = M1temp.col(1);
M1.col(2) = M1temp.col(2);
M1.col(3) = M1temp.col(3);
M1.col(4) = M1temp.col(4);
M1.col(5) = M1temp.col(5);
M1.col(6) = M1temp.col(6);
M1.col(7) = M1temp.col(7);
M1.col(8) = M1temp.col(8);
M1.col(9) = M1temp.col(9);

Eigen::MatrixXd  M2(25,33);
M2.fill(0.0);
static const int ind_2_0 [] = {0,4,5,8,14,15,18,23};
static const int ind_1_0 [] = {0,3,4,5,6,7,8,9};
initRow( M2, M1, 0, 0, ind_2_0, ind_1_0, 8  );
static const int ind_2_1 [] = {0,3,4,7,13,14,17,22};
static const int ind_1_1 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 1, 1, ind_2_1, ind_1_1, 8  );
static const int ind_2_2 [] = {1,5,6,9,15,16,19,24};
static const int ind_1_2 [] = {0,3,4,5,6,7,8,9};
initRow( M2, M1, 2, 0, ind_2_2, ind_1_2, 8  );
static const int ind_2_3 [] = {1,4,5,8,14,15,18,23};
static const int ind_1_3 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 3, 1, ind_2_3, ind_1_3, 8  );
static const int ind_2_4 [] = {1,3,4,7,13,14,17,22};
static const int ind_1_4 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 4, 2, ind_2_4, ind_1_4, 8  );
static const int ind_2_5 [] = {2,5,6,9,15,16,19,24};
static const int ind_1_5 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 5, 1, ind_2_5, ind_1_5, 8  );
static const int ind_2_6 [] = {2,4,5,8,14,15,18,23};
static const int ind_1_6 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 6, 2, ind_2_6, ind_1_6, 8  );
static const int ind_2_7 [] = {3,7,8,10,17,18,20,26};
static const int ind_1_7 [] = {0,3,4,5,6,7,8,9};
initRow( M2, M1, 7, 0, ind_2_7, ind_1_7, 8  );
static const int ind_2_8 [] = {4,7,8,10,17,18,20,26};
static const int ind_1_8 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 8, 1, ind_2_8, ind_1_8, 8  );
static const int ind_2_9 [] = {5,8,9,11,18,19,21,27};
static const int ind_1_9 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 9, 1, ind_2_9, ind_1_9, 8  );
static const int ind_2_10 [] = {5,7,8,10,17,18,20,26};
static const int ind_1_10 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 10, 2, ind_2_10, ind_1_10, 8  );
static const int ind_2_11 [] = {6,8,9,11,18,19,21,27};
static const int ind_1_11 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 11, 2, ind_2_11, ind_1_11, 8  );
static const int ind_2_12 [] = {9,10,11,12,20,21,25,28};
static const int ind_1_12 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 12, 2, ind_2_12, ind_1_12, 8  );
static const int ind_2_13 [] = {13,17,18,20,22,23,26,29};
static const int ind_1_13 [] = {0,3,4,5,6,7,8,9};
initRow( M2, M1, 13, 0, ind_2_13, ind_1_13, 8  );
static const int ind_2_14 [] = {14,18,19,21,23,24,27,30};
static const int ind_1_14 [] = {0,3,4,5,6,7,8,9};
initRow( M2, M1, 14, 0, ind_2_14, ind_1_14, 8  );
static const int ind_2_15 [] = {14,17,18,20,22,23,26,29};
static const int ind_1_15 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 15, 1, ind_2_15, ind_1_15, 8  );
static const int ind_2_16 [] = {15,18,19,21,23,24,27,30};
static const int ind_1_16 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 16, 1, ind_2_16, ind_1_16, 8  );
static const int ind_2_17 [] = {15,17,18,20,22,23,26,29};
static const int ind_1_17 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 17, 2, ind_2_17, ind_1_17, 8  );
static const int ind_2_18 [] = {16,18,19,21,23,24,27,30};
static const int ind_1_18 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 18, 2, ind_2_18, ind_1_18, 8  );
static const int ind_2_19 [] = {17,20,21,25,26,27,28,31};
static const int ind_1_19 [] = {0,3,4,5,6,7,8,9};
initRow( M2, M1, 19, 0, ind_2_19, ind_1_19, 8  );
static const int ind_2_20 [] = {18,20,21,25,26,27,28,31};
static const int ind_1_20 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 20, 1, ind_2_20, ind_1_20, 8  );
static const int ind_2_21 [] = {19,20,21,25,26,27,28,31};
static const int ind_1_21 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 21, 2, ind_2_21, ind_1_21, 8  );
static const int ind_2_22 [] = {22,26,27,28,29,30,31,32};
static const int ind_1_22 [] = {0,3,4,5,6,7,8,9};
initRow( M2, M1, 22, 0, ind_2_22, ind_1_22, 8  );
static const int ind_2_23 [] = {23,26,27,28,29,30,31,32};
static const int ind_1_23 [] = {1,3,4,5,6,7,8,9};
initRow( M2, M1, 23, 1, ind_2_23, ind_1_23, 8  );
static const int ind_2_24 [] = {24,26,27,28,29,30,31,32};
static const int ind_1_24 [] = {2,3,4,5,6,7,8,9};
initRow( M2, M1, 24, 2, ind_2_24, ind_1_24, 8  );

Eigen::PartialPivLU<Eigen::MatrixXd> lu(M2.block(0,0,25,25));
Eigen::MatrixXd M3 = lu.solve(M2.block(0,25,25,8));
Eigen::Matrix<double,8,8> Action = Eigen::Matrix<double,8,8>::Zero();
Action.row(0) -= M3.block(12,0,1,8);
Action.row(1) -= M3.block(20,0,1,8);
Action.row(2) -= M3.block(21,0,1,8);
Action(3,0) = 1.0;
Action(4,1) = 1.0;
Action(5,2) = 1.0;
Action(6,3) = 1.0;
Action(7,6) = 1.0;
//columns of Action mean:
// x_3^3 x_1*x_3 x_2*x_3 x_3^2 x_1 x_2 x_3 1

  Eigen::EigenSolver< Eigen::Matrix<double,8,8> > Eig(Action,true);
  Eigen::Matrix<std::complex<double>,8,1> D = Eig.eigenvalues();
  Eigen::Matrix<std::complex<double>,8,8> V = Eig.eigenvectors();

  for( int c = 0; c < 8; c++ )
  {
    std::complex<double> eigValue = D[c];

    if( fabs(eigValue.imag()) < 0.0001 )
    {
      Eigen::Matrix<double,3,1> sol;

      std::complex<double> temp;
      temp = V(4,c) / V(7,c);
      sol(0,0) = temp.real();
      temp = V(5,c) / V(7,c);
      sol(1,0) = temp.real();
      temp = V(6,c) / V(7,c);
      sol(2,0) = temp.real();
      solutions.push_back(sol);
    }
  }
}